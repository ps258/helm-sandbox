#!/bin/ksh

# install cert manager if needed
#if ! kubectl get ns | grep -qw cert-manager; then
#  echo kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v1.19.1/cert-manager.yaml --wait
#fi

# Globals
SCRIPTNAME=$0
SCRIPTDIR=$(
  cd "$(dirname $SCRIPTNAME)"
  echo $PWD
)
SCRIPTNAME=$(basename $SCRIPTNAME)
VERSIONFILE="$SCRIPTDIR/tyk-versions.list"
NAMESPACE_SELECTOR_LABEL="creator=hsbctl"
NAMESPACE=''
HSBX_DATABASE=mongo
HSBX_DESCRIPTION='N/A'
HSBX_GATE_VERS=''
HSBX_GATE_PLUGIN_DIR=''
HSBX_GATE_EE=''
HSBX_DASH_VERS=''
HSBX_ENABLE_EDP=false
HSBX_PUMP_VERS=''
HSBX_MDCB_VERS=''
HSBX_EDP_VERS=''
HSBX_MDCB_LICENSE=''
HSBX_ADMIN_SECRET=admin_secret
HSBX_GATE_SECRET=Secret
HSBX_PGPASSWORD=password   # default postgres password
HSBX_PGUSER=postgresx      # default postgres username
HSBX_PGDB=tyk_analytics    # default postgres database
HSBX_TYK_K8S_SECRETS=tyk-system-secrets  # licences and admin secrets
HSBX_ADMIN_ACCOUNT_SECRETS=tyk-admin-account-secrets # Admin user details
HSBX_EDP_SECRET=tyk-EDP-secret
HSBX_REDIS_DB_SIZE=1      # the size to make the redis persistent volume claim for both control plane and edge deployment
HSBX_PG_MAIN_DB_SIZE=5    # the size to make the mongo or postgresql DB persistent volume claim
HSBX_PG_PORTAL_THEMES_SIZE=2   # the size to make EDP's /opt/portal/themes volume for storing themes
HSBX_CHART=tyk-stack
REDIS_PASSWORD=''
MONGODB_SECRETS=mongourl-secrets
PG_SERETS=postgres-secrets

# set the services to NodePort
HELM_TYK_GATEWAY_SERVICE_TYPE=NodePort
HELM_TYK_GATEWAY_CONTROL_TYPE=NodePort
HELM_TYK_PUMP_SERVICE_TYPE=NodePort
HELM_TYK_DASHBOARD_SERVICE_TYPE=NodePort

HELM_SET_MONGO_DRIVER=''
HELM_SET_MONGO_URL_SECRET_NAME=''
HELM_SET_MONGO_URL_SECRET_KEYNAME=''

HELM_SET_PG_CONNECTION_SECRET_NAME=''
HELM_SET_PG_CONNECTION_SECRET_KEYNAME=''


HELM_TYK_RELEASE_NAME=tykstack
REDIS_BITNAMI_CHART_VERSION=19.0.2
MONGO_BITNAMI_CHART_VERSION=15.1.3
POSTGRES_BITNAMI_CHART_VERSION=12.12.10
ADMIN_EMAIL=''
ADMIN_PASSWORD=''

# if the standard setup file exists take defaults from that
if [[ -f ~/.tyk-sandbox ]]; then
  . ~/.tyk-sandbox
else
  SBX_LICENSE=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhbGxvd2VkX25vZGVzIjoiNjk0NWIwMWMtZWU5NS00YWZmLTQ1ZWEtOTkxMTgzZjZlNWY2LDQwMTlmZWY0LTM5NzktNDJiZi00ZDFmLTAxMTFkMGUxMDUwMCw1Y2E4NjhmNC1iMzAyLTQyMjUtNmY5Zi1kNTIwNjllOGIyMzQsNjI5NWFiZjktYTNmOC00Y2RjLTVmMDQtY2I4MjRiMDhhMDU5LGRlOWYzMjAxLTdkMTUtNDVhYS03NDE1LTEzZmVhYjEzY2U3ZSxmMjdiZGFlMi05MDUwLTRmMGQtNTIxMy0xZWI0YjI3YjAyOGEsOTVjMGY2YzMtYzFjNS00OGJmLTUzNDktMTY3NmNiOWM5Y2U0LGUzMjYxYjRiLWJlODctNDVhZi03NzhiLWViYTViMDQ5YmE3ZCwzNWE2NjYxMi1hYjgwLTQ0MTktNDFhNS01NmZmZmZiMjYxN2EsMmFlYjJkODEtYjE3MC00MTNiLTUzYjEtOTA5NTE0NTRhZTRiIiwiZXhwIjoxNzQ2NjYyMzk5LCJoaWQiOiJwZXRlci5zIiwiaWF0IjoxNzQ0MDIwMjQ3LCJsaWNlbnNlX3R5cGUiOiJpbnRlcm5hbCIsIm93bmVyIjoiNjFjY2U2MmMxMjFjYTEwMDAxOGJiMTkwIiwic2NvcGUiOiJtdWx0aV90ZWFtLHJiYWMsZ3JhcGgsZmVkZXJhdGlvbixzdHJlYW1zLHRyYWNrIiwidiI6IjIifQ.YtjKFa_m13RNDHloUBMcYGB1TG82LIX9XOmSEhYkIQVTPKxvV0h2oZRuYMui9oDyauzEcrc7jzU9bZAvL4acXX74D7oq_f0_rV_rWBR9abQlEO5wZ2RGaLn2qO-XiA-vYQtzXiNfKDFMLrAOmLCHuH8zDkg4Rs4mBJ9d8MQ8EbcD_pFXpgVsP7haEWgLnojEFzeN9HoDTc2JnXV3UmFi67KN8OwcMczmERNzDPzTa12JhC37R029SA6dru2Q0BzGa_P8VoIMFvoLtXCHExrUAAbH_ZvA_6wF-0As4JN4LsQ0u4I5HZ4ELSt0kdgX7GbO7QiMNWmlvvytQwKDRmgQog
  SBX_USER=user@admin.com
  SBX_PASSWORD=ABC-123
fi

function help {
  typeset name
  name=$SCRIPTNAME
  echo "[USAGE]: $name create -v <tyk version> -t <namespace description> -N <namespace name> [-p|-s] [-c gateway_count] [-e edge_gw_count] [-m] [-o] [-i]"
  echo "      Create a tyk instance in a namespace sandbox with the version given as a tag with -v"
  echo "      -c The number of control plane gateway replicas to run. NOT YET IMPLEMENTED"
  echo "      -C The chart to deploy. Defaults to tyk-stack which is currently the only supported option"
  echo "      -D The size of the allocated Mongo or PG storage in GiB (default: $HSBX_PG_MAIN_DB_SIZE) NOT YET IMPLEMENTED"
  echo "      -E A file to read environment variables from and add them all deployments. NOT YET IMPLEMENTED"
  echo "      -N Use the given namespace name rather than the next available sandbox"
  echo "         Useful when there's a need to import apis and policy YAML with set namespace"
  echo "      -p Deploy with postgres not mongo. NOT YET IMPLEMENTED"
  echo "      -P Deploy with EDP. (Implies -p)"
  echo "      -R The size of the allocated redis control or data plane storage in GiB (default: $HSBX_REDIS_DB_SIZE) NOT YET IMPLEMENTED"
  echo "      -t Description of the sandbox namespace"
  echo "      -v Version tag. The file $VERSIONFILE contains the versions used"
  echo "$name delete <sandbox namespace...>"
  echo "      Delete the sandbox namespace given as a tag and all resources in it"
  echo "$name info <sandbox namespace...>"
  echo "      Print info detailed info on sandbox namespaces"
}

function listPods {
  kubectl get pods -n $NAMESPACE
}

# Wait for something to be ready
function waitResourceReady {
  typeset resourcetype
  typeset waitfor
  resourcetype=$1
  waitfor=$2
  if [[ -n $waitfor ]]; then
    if kubectl get $resourcetype --no-headers=true -n $NAMESPACE $waitfor > /dev/null 2>&1; then
      echo -n "[INFO]Waiting for $resourcetype $NAMESPACE:$waitfor to be ready."
      while [[ $( kubectl get $resourcetype --no-headers=true -n $NAMESPACE $waitfor | awk -F '[ /]+' 'BEGIN{allup=0} {up=$2 - $3; if (up != 0) {allup=up}}; END{print allup}' ) -ne 0 ]]; do
        echo -n .
        sleep 5
      done
    else
      echo "[FATAL]Cannot find a $resourcetype matching '$2'"
      exit 1
    fi
  fi
  echo " done"
}

# Wait for a deployment to be ready.
function waitDeploymentReady {
  typeset deploymentName
  for deploymentName in "$@"; do
    waitResourceReady deployment "$deploymentName"
  done
}

# Wait for a deployment to be ready.
function waitStatefulSetReady {
  typeset statefulsetName
  for statefulsetName in "$@"; do
    waitResourceReady statefulset "$statefulsetName"
  done
}

# find the next namespace index that's unused
function nextFreeNamespace {
  typeset existing
  typeset i
  existing=$(kubectl get namespaces --selector=$NAMESPACE_SELECTOR_LABEL --no-headers=true 2>/dev/null | awk '{print $1}')
  for i in $(seq 1 1000); do
    test="hsandbox-$i"
    if ! echo $existing | grep -qw $test; then
      echo $i
      break
    fi
  done
}

function getAllSandboxes {
  kubectl get namespaces --selector=$NAMESPACE_SELECTOR_LABEL --no-headers=true 2>/dev/null | awk '{print $1}' | xargs
}

# allow the shortcut of using 1 to mean hsandbox-1 on the commandline
function getNamespaceNames {
  typeset namespaces
  typeset namespace
  namespaces=''
  for namespace in $*; do
    if ! namespaceExists $namespace; then
      if ! echo $namespace | grep -q hsandbox- ; then
        namespaces="$namespaces hsandbox-$namespace"
      else
        namespaces="$namespaces $namespace"
      fi
    else
      namespaces="$namespaces $namespace"
    fi
  done
  echo $namespaces
}

# read the versions file and create an array of associated versions
# isolated to keep IFS from leaking
function loadVersions {
  typeset line
  typeset IFS
  typeset gwVers
  typeset dshbVers
  typeset pumpVers
  typeset TIBvers
  typeset syncVers
  typeset MDCBvers
  typeset EDPvers
  typeset version
  line=$1
  IFS=,
  echo "$line" | read version gwVers dshbVers pumpVers TIBvers syncVers MDCBvers EDPvers
  export HSBX_GATE_PLUGIN_DIR="$gwVers"
  if [[ ! -d $HOME/.tyk/plugins/$HSBX_GATE_PLUGIN_DIR ]]; then
    mkdir -p $HOME/.tyk/plugins/$HSBX_GATE_PLUGIN_DIR
  fi
  export HSBX_GATE_VERS="v${gwVers%%-1}"
  if echo $HSBX_GATE_VERS | grep -q ee; then
    HSBX_GATE_EE='-ee'
  else
    HSBX_GATE_EE=''
  fi
  HSBX_GATE_VERS=$(echo $HSBX_GATE_VERS | sed 's/ee-//g')
  HSBX_GATE_VERS=$(echo $HSBX_GATE_VERS | sed 's/~/-/g')
  HSBX_DASH_VERS="v${dshbVers%%-1}"
  HSBX_PUMP_VERS="v${pumpVers%%-1}"
  HSBX_EDP_VERS="v${EDPvers%%-1}"
  HSBX_MDCB_VERS="v${MDCBvers%%-1}"
}

function getMinikubeIP {
  minikube profile list -l 2> /dev/null | awk '/'$CLUSTER'/ {print $8}'
}

function namespaceExists {
  typeset namespace
  typeset ns
  namespace=$1
  for ns in $(kubectl get namespaces --no-headers=true | awk '{print $1}'); do
    if [[ "$ns" == $namespace ]]; then
      return 0
    fi
  done
  return 1
}

# create a namespace for the sandbox and save labels that say what it's for etc.
# these labels are used internally and are also helpful for remembering why you created the sandbox
function createNamespace {
  typeset configYAML
  configYAML=$(mktemp /tmp/configYAML.yaml.XXXX)
  if ! namespaceExists $NAMESPACE; then
    echo "[INFO]kubectl create ns $NAMESPACE"
    kubectl create ns $NAMESPACE
    echo "[INFO]kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR_LABEL $EXTRA_NAMESPACE_LABELS"
    kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR_LABEL $EXTRA_NAMESPACE_LABELS
    # setup config map in the new namespace with the details of the deployment
    echo "apiVersion: v1" > $configYAML
    echo "data:" >> $configYAML
    if [[ -n $sandboxVersion ]]; then
      echo "  HSBX_VERSION: $sandboxVersion" >> $configYAML
    fi
    if [[ -n $HSBX_GATE_VERS ]]; then
      echo "  HSBX_GW: $HSBX_GATE_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_DASH_VERS ]]; then
      echo "  HSBX_DB: $HSBX_DASH_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_PUMP_VERS ]]; then
      echo "  HSBX_PMP: $HSBX_PUMP_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_MDCB_VERS ]]; then
      echo "  HSBX_MDCB: $HSBX_MDCB_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_EDP_VERS ]]; then
      echo "  HSBX_EDP: $HSBX_EDP_VERS" >> $configYAML
    fi
    echo "  HSBX_TYPE: $HSBX_TYPE" >> $configYAML
    if [[ $HSBX_TYPE == 'pro' || $HSBX_TYPE == 'mdcb' ]]; then
      echo "  HSBX_DATABASE: $HSBX_DATABASE" >> $configYAML
    fi
    echo "  HSBX_DESCRIPTION: \"$HSBX_DESCRIPTION\"" >> $configYAML
    echo "kind: ConfigMap" >> $configYAML
    echo "metadata:" >> $configYAML
    echo "  namespace: \"$NAMESPACE\"" >> $configYAML
    echo "  name: sandbox-details" >> $configYAML
    kubectl apply -f $configYAML -n $NAMESPACE
    echo "[INFO]Created namespace '$NAMESPACE'"
  fi
  rm -f $configYAML
  setupTykSystemSecrets
  setupAdminAccountSecrets
}

# setup secrets like licences and the Admin secret
function setupTykSystemSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_TYK_K8S_SECRETS; then
    kubectl create secret generic $HSBX_TYK_K8S_SECRETS -n $NAMESPACE \
      --from-literal=APISecret=$HSBX_GATE_SECRET \
      --from-literal=AdminSecret=$HSBX_ADMIN_SECRET \
      --from-literal=DashLicense=$SBX_LICENSE \
      --from-literal=DevPortalLicense=$SBX_LICENSE \
      --from-literal=OperatorLicense=$SBX_LICENSE
  fi
}

# setup secrets for the dashboard admin user
function setupAdminAccountSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_ADMIN_ACCOUNT_SECRETS; then
    kubectl create secret generic $HSBX_ADMIN_ACCOUNT_SECRETS -n $NAMESPACE \
      --from-literal=adminUserFirstName=Admin \
      --from-literal=adminUserLastName=User \
      --from-literal=adminUserEmail=$ADMIN_EMAIL \
      --from-literal=adminUserPassword=$ADMIN_PASSWORD
  fi
}

# deploy redis
function deployRedis {
  if ! helm list -n $NAMESPACE | grep -qw tyk-redis; then
    helm upgrade tyk-redis oci://registry-1.docker.io/bitnamicharts/redis --set image.repository=bitnamilegacy/redis -n $NAMESPACE --install --version $REDIS_BITNAMI_CHART_VERSION > /dev/null
    echo "[INFO]Sleeping to let redis start"
    waitStatefulSetReady tyk-redis-master tyk-redis-replicas
  fi
}

# fetch the redis password from the tyk-redis secret, decode it and save it into REDIS_PASSWORD
function redisPassword {
  kubectl get secret --namespace $NAMESPACE tyk-redis -o jsonpath="{.data.redis-password}" | base64 -d
}

# deploy postgres
function deployPostgres {
  if ! helm list -n $NAMESPACE | grep -qw tyk-postgres; then
    helm upgrade tyk-postgres oci://registry-1.docker.io/bitnamicharts/postgresql --set image.repository=bitnamilegacy/postgresql --set "auth.database=tyk_analytics" -n $NAMESPACE --install --version $POSTGRES_BITNAMI_CHART_VERSION > /dev/null
    waitStatefulSetReady tyk-postgres-postgresql
    HELM_SET_PG_CONNECTION_SECRET_NAME="--set global.postgres.connectionStringSecret.name=$PG_SERETS"
    HELM_SET_PG_CONNECTION_SECRET_KEYNAME="--set global.postgres.connectionStringSecret.keyName=postgresConnectionString"
  fi
}

function postgresSetupSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $PG_SERETS; then
    POSTGRES_PASSWORD=$(postgressPassword)
    POSTGRES_CONNECTION_STRING="user=postgres password=$POSTGRES_PASSWORD database=tyk_analytics host=tyk-postgres-postgresql port=5432"
    kubectl create secret generic $PG_SERETS -n $NAMESPACE --from-literal=postgresConnectionString="$POSTGRES_CONNECTION_STRING"
  fi
}

function postgressPassword {
  kubectl get secret --namespace $NAMESPACE tyk-postgres-postgresql -o jsonpath="{.data.postgres-password}" | base64 -d
}

# deploy mongodb
function deployMongodb {
  if ! helm list -n $NAMESPACE | grep -qw tyk-mongo; then
    helm upgrade tyk-mongo oci://registry-1.docker.io/bitnamicharts/mongodb --set image.repository=bitnamilegacy/mongodb -n $NAMESPACE --install --version $MONGO_BITNAMI_CHART_VERSION > /dev/null
    echo "[INFO]Sleeping let mongodb start"
    waitDeploymentReady tyk-mongo-mongodb
    HELM_SET_MONGO_DRIVER="--set global.mongo.driver=mongo-go"
    HELM_SET_MONGO_URL_SECRET_NAME="--set global.mongo.connectionURLSecret.name=$MONGODB_SECRETS"
    HELM_SET_MONGO_URL_SECRET_KEYNAME="--set global.mongo.connectionURLSecret.keyName=mongoUrl"
  fi
}

# retrieve the mongodb secrets from the MONGODB_SECRETS decode and save into MONGODB_ROOT_PASSWORD and MONGODB_URL
function mongoSetupSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $MONGODB_SECRETS; then
    MONGODB_ROOT_PASSWORD=$(mongoPassword)
    MONGODB_URL="mongodb://root:$MONGODB_ROOT_PASSWORD@tyk-mongo-mongodb.$NAMESPACE.svc:27017/tyk_analytics?authSource=admin"
    if ! kubectl get secret -n $NAMESPACE | grep -qw $MONGODB_SECRETS; then
      kubectl create secret generic $MONGODB_SECRETS --from-literal=mongoUrl=$MONGODB_URL -n $NAMESPACE
    fi
  fi
}

function mongoPassword {
  kubectl get secret --namespace $NAMESPACE tyk-mongo-mongodb -o jsonpath="{.data.mongodb-root-password}" | base64 -d
}


# setup EDP secrets
function setupEDPSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_EDP_PORTAL_SECRET; then
    kubectl create secret generic $HSBX_EDP_PORTAL_SECRET -n $NAMESPACE \
      --from-literal=DevPortalDatabaseConnectionString=db/portal.db \
      --from-literal=DevPortalLicense=$SBX_LICENSE
      # these cant be used until TT-14957 is fixed
      #    --from-literal=adminUserFirstName=Admin_first \
      #    --from-literal=adminUserLastName=Admin_last \
  fi
}

# install the tyk repo and update
function installTykHelmRepo {
  if ! helm repo list | grep -wq tyk-helm; then
    helm repo add tyk-helm https://helm.tyk.io/public/helm/charts/
  fi
  helm repo update
}

function runHelm {
  helm upgrade $HELM_TYK_RELEASE_NAME tyk-helm/$HSBX_CHART -n $NAMESPACE \
    --install \
    --set global.adminUser.useSecretName=$HSBX_ADMIN_ACCOUNT_SECRETS \
    --set global.secrets.useSecretName=$HSBX_TYK_K8S_SECRETS \
    --set global.components.operator=false \
    --set global.components.devPortal=$HELM_TYK_DEVPORTAL_ENABLED \
    --set global.storageType=$HELM_GLOBAL_STORAGETYPE \
    --set global.redis.addrs="{tyk-redis-master.$NAMESPACE.svc:6379}" \
    --set global.redis.passSecret.name=tyk-redis \
    --set global.redis.passSecret.keyName=redis-password \
    --set tyk-dashboard.dashboard.image.tag=$HSBX_DASH_VERS \
    --set tyk-dashboard.dashboard.service.type=$HELM_TYK_DASHBOARD_SERVICE_TYPE \
    $HELM_SET_MONGO_DRIVER \
    $HELM_SET_MONGO_URL_SECRET_NAME \
    $HELM_SET_MONGO_URL_SECRET_KEYNAME \
    $HELM_SET_PG_CONNECTION_SECRET_NAME \
    $HELM_SET_PG_CONNECTION_SECRET_KEYNAME \
    $HELM_SET_TYK_DEVPORTAL_USESECRETNAME \
    $HELM_SET_TYK_DEVPORTAL_EXTRAENVS0NAME \
    $HELM_SET_TYK_DEVPORTAL_EXTRAENVS0VALUE \
    $HELM_SET_TYK_DEVPORTAL_IMAGE_TAG \
    $HELM_SET_TYK_DEVPORTAL_SERVICE \
    --set tyk-gateway.gateway.image.tag=$HSBX_GATE_VERS \
    --set tyk-gateway.gateway.service.type=$HELM_TYK_GATEWAY_SERVICE_TYPE \
    --set tyk-gateway.gateway.control.type=$HELM_TYK_GATEWAY_CONTROL_TYPE \
    --set tyk-pump.pump.image.tag=$HSBX_PUMP_VERS \
    --set tyk-pump.pump.service.type=$HELM_TYK_PUMP_SERVICE_TYPE  > /dev/null
    #--set tyk-pump.pump.backend="{$HELM_GLOBAL_STORAGETYPE}" > /dev/null
}

# report the ports to access services
function showServices {
  typeset catcmd
  if which cols >/dev/null ; then
    catcmd=cols
  else
    catcmd=cat
  fi
  IP=$(minikube ip)
  kubectl get svc -n $NAMESPACE | awk '/NodePort/ {print $1, $5}' | while read svc port; do
    port=$(echo $port | cut -d: -f2 | cut -d/ -f1)
    echo "$svc -> http://$IP:$port"
  done | $catcmd
}

# Process commands and take actions
if [[ $# -gt 0 ]]; then
  case $1 in 
    create)
      shift
      while getopts :C:D:E:N:PpR:t:v: arg; do
        case $arg in
          c)
            # the number of control gateways to deploy (these are also just gateways in the pro install)
            # defaults to one
            HSBX_CONTROL_GATEWAY_REPLICAS=$OPTARG
            ;;
          C)
            # this is the chart to deploy. Defaults to tyk-stack
            HSBX_CHART=$OPTARG
            ;;
          D)
            # The size of the allocated Mongo or PG storage in GiB
            HSBX_PG_MAIN_DB_SIZE=$(echo $OPTARG | tr -cd 0-9)
            ;;
          E)
            # global environment variable file
            ENV_VAR_FILE=$OPTARG
            if [[ ! -f $ENV_VAR_FILE ]]; then
              echo "[FATAL]Cannot read environment variable file: '$ENV_VAR_FILE'"
              exit 1
            fi
            ;;
          N)
            # specify a particular namespace
            NAMESPACE=$OPTARG
            ;;
          P)
            # deploy EDP must deploy PG as well then
            HSBX_DATABASE=postgres
            HSBX_ENABLE_EDP=true
            ;;
          p)
            # use postgresql not mongodb
            # defaults to mongo without this
            HSBX_DATABASE=postgres
            ;;
          R)
            # The size of the allocated control and data plane redis storage in GiB
            HSBX_REDIS_DB_SIZE=$(echo $OPTARG | tr -cd 0-9)
            ;;
          t)
            # the description of the namespace or sandbox
            HSBX_DESCRIPTION="$OPTARG"
            ;;
          v)
            # the base version to use to look up the versions of each of the products
            sandboxVersion=$OPTARG
            ;;
          :)
            echo "[FATAL]Option -$OPTARG requires an arguement."
            exit 1
            ;;
          \?)
            echo "[FATAL]Invalid option: -$OPTARG"
            exit 1
            ;;
        esac
      done
      if [[ -z $NAMESPACE ]]; then
        NAMESPACE=hsandbox-$(nextFreeNamespace)
      fi
      if [[ -z $sandboxVersion ]]; then
        echo "[FATAL]Must specify a release version"
        help
        exit 1
      fi
      if ! namespaceExists $NAMESPACE; then
        HSBX_NS=$NAMESPACE
        export HSBX_NS
        if [[ $HSBX_DATABASE == 'postgres' ]]; then
          if ! echo $sandboxVersion | awk -F. '$1>3{exit 0} $1<4{exit 1}'; then
            echo "[FATAL]Version must be 4 or later to use postgres"
            exit 1
          fi
        fi
        # export namespace for envsubst to pick up
        if egrep -q "^$sandboxVersion," $VERSIONFILE; then
          loadVersions $(grep -e "^$sandboxVersion," $VERSIONFILE | head -1)
          echo -n "[INFO]Using Gateway $HSBX_GATE_VERS, Dashboard $HSBX_DASH_VERS, Pump $HSBX_PUMP_VERS"
          if [[ -n $HSBX_MDCB_VERS ]]; then
            echo -n ", MDCB $HSBX_MDCB_VERS"
          fi
          if [[ -n $HSBX_EDP_VERS ]]; then
            echo -n ", EDP $HSBX_EDP_VERS"
          fi
          echo
        else
          echo "[FATAL]Unable to find '$sandboxVersion' in '$VERSIONFILE'"
          exit 1
        fi
        createNamespace
        # setup redis and save the passwords
        deployRedis
        if [[ -n $ENV_VAR_FILE ]]; then
          # create a config map to hold the environment variables
          echo "[INFO]Adding environment variables from $ENV_VAR_FILE to configmap sandbox-env-vars"
          kubectl create configmap sandbox-env-vars --from-env-file=$ENV_VAR_FILE -n $NAMESPACE
        fi
        if [[ $HSBX_DATABASE == 'mongo' ]]; then
          deployMongodb
          mongoSetupSecrets
          HELM_GLOBAL_STORAGETYPE="mongo"
        else
          HELM_GLOBAL_STORAGETYPE="postgres"
          deployPostgres
          postgresSetupSecrets
        fi
        if [[ $HSBX_ENABLE_EDP == 'true' ]]; then
          HELM_TYK_DEVPORTAL_ENABLED=true
          HELM_SET_TYK_DEVPORTAL_USESECRETNAME="--set tyk-dev-portal.useSecretName=$DEV_PORTAL_SECRET"
          HELM_SET_TYK_DEVPORTAL_EXTRAENVS0NAME='--set tyk-dev-portal.extraEnvs[0].name=PORTAL_DISABLE_CSRF_CHECK'
          HELM_SET_TYK_DEVPORTAL_EXTRAENVS0VALUE='--set tyk-dev-portal.extraEnvs[0].value=true'
          HELM_SET_TYK_DEVPORTAL_IMAGE_TAG="--set set tyk-dev-portal.image.tag=$HSBX_EDP_VERS"
          HELM_SET_TYK_DEVPORTAL_SERVICE="--set tyk-dev-portal.service.type=NodePort"
        else
          HELM_TYK_DEVPORTAL_ENABLED=false
        fi
        runHelm
        echo "[INFO]$NAMESPACE"
        listPods
        showServices
      else
        echo "[FATAL]Namespace $NAMESPACE already exists"
        exit 1
      fi

      ;;
    info)
      shift
      if [[ $# -lt 1 ]]; then
        # give info on all if none given
        typeset allSandboxes
        allSandboxes=$(getAllSandboxes)
        if [[ $allSandboxes = '' ]]; then
          echo "[INFO]No sandboxes configured"
          exit 0
        fi
        set $allSandboxes
      fi
      for NAMESPACE in $(getNamespaceNames $*); do
        if namespaceExists $NAMESPACE; then
          echo "[INFO]$NAMESPACE"
          listPods
          showServices
          echo
        else
          echo "[WARN]Namespace '$NAMESPACE' not found"
        fi
      done
      ;;
    rm | del*)
      shift
      if [[ $# -lt 1 ]]; then
        echo "[FATAL]Must provide namespace"
        exit 1
      fi
      for NAMESPACE in $(getNamespaceNames $*); do
        if namespaceExists $NAMESPACE; then
          echo "[INFO]Deleting Namespace $NAMESPACE"
          kubectl delete namespace $NAMESPACE --wait
        fi
      done
      ;;
    :)
      echo "[FATAL]Option -$OPTARG requires an arguement."
      exit 1
      ;;
    \?)
      echo "[FATAL]Invalid option: -$OPTARG"
      exit 1
      ;;
  esac
else
  help
  exit 1
fi

