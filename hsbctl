#!/bin/ksh

# install cert manager if needed
#if ! kubectl get ns | grep -qw cert-manager; then
#  echo kubectl apply --validate=false -f https://github.com/jetstack/cert-manager/releases/download/v1.19.1/cert-manager.yaml --wait
#fi

# Globals
SCRIPTNAME=$0
SCRIPTDIR=$(
  cd "$(dirname $SCRIPTNAME)"
  echo $PWD
)
SCRIPTNAME=$(basename $SCRIPTNAME)
VERSIONFILE="$SCRIPTDIR/tyk-versions.list"
YAMLDIR="$SCRIPTDIR/YAML"

NAMESPACE_SELECTOR_LABEL="creator=hsbctl"
ISTIO_INJECTION_LABEL='istio-injection=enabled'
HELM_TYKSTACK_RELEASE_NAME=tykstack
HELM_TYKCONTROLPLANE_RELEASE_NAME=tykcontrolplane
HELM_DATAPLANE_RELEASE_NAME=tykdataplane

# secret things and places to store secrets
HSBX_ADMIN_SECRET=admin_secret
HSBX_GATE_SECRET=Secret
# this is hard coded in the chart. See TT-16036
# we set it in function setupDevPortalSecrets
HSBX_DEVPORTAL_PORTAL_SECRET=""
HSBX_TYK_K8S_SECRETS=tyk-system-secrets  # licences and admin secrets
HSBX_ADMIN_ACCOUNT_SECRETS=tyk-admin-account-secrets # Admin user details
HSBX_REMOTE_CONTROL_PLANE_SECRETS=tyk-remote-control-plane-secrets
MONGODB_SECRETS=mongourl-secrets
POSTGRES_SECRETS=postgres-secrets

NAMESPACE=''
HSBX_DATABASE=mongo
HSBX_DESCRIPTION='N/A'
HSBX_GATE_USE_HTTPS=false
HSBX_GATE_VERS=''
HSBX_GATE_PLUGIN_DIR=''
HSBX_GATE_EE=''
HSBX_DASH_VERS=''
HSBX_ENABLE_DEVPORTAL=false
HSBX_PUMP_VERS=''
HSBX_MDCB_VERS=''
HSBX_DEVPORTAL_VERS=''
HSBX_MDCB_LICENCE=''
HSBX_VALUES_FILE=''
HSBX_PGUSER=postgres      # default postgres username
HSBX_PGDB=tyk_analytics   # default postgres database
HSBX_REDIS_REPLICAS=0     # the number of redis replicas to run. It slows creation of a sandbox significantly to have these enabled
HSBX_REDIS_DB_SIZE=1      # the size to make the redis PVC for both control plane and data plane deployment
HSBX_MAIN_DB_SIZE=5       # the size to make the mongo or postgresql DB PVC
HSBX_PORTAL_THEMES_SIZE=2 # the size to make EDP's /opt/portal/themes volume for storing themes (not implemented yet)
HSBX_CHART=tyk-stack
REDIS_PASSWORD=''

# set the services to NodePort
HELM_TYK_GATEWAY_SERVICE_TYPE=NodePort
HELM_TYK_GATEWAY_CONTROL_TYPE=NodePort
HELM_TYK_PUMP_SERVICE_TYPE=NodePort
HELM_TYK_DASHBOARD_SERVICE_TYPE=NodePort
HELM_TYK_MDCB_SERVICE_TYPE=NodePort

# when adding extra envs we need to know what array index we're up to so we need to keep track of those
# the convention is to use this value then increment it
HELM_TYK_DASHBOARD_EXTRAENVS_NEXT_INDEX=0
HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX=0
HELM_TYK_PUMP_EXTRAENVS_NEXT_INDEX=0
HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX=0
# These are the variables for keeping all of the extra envs in
HELM_SET_TYK_DASHBOARD_EXTRAENVS=''
HELM_SET_TYK_GATEWAY_EXTRAENVS=''
HELM_SET_TYK_PUMP_EXTRAENVS=''
HELM_SET_TYK_DEVPORTAL_EXTRAENVS=''

HELM_SET_MONGO_DRIVER=''
HELM_SET_MONGO_URL_SECRET_NAME=''
HELM_SET_MONGO_URL_SECRET_KEYNAME=''

HELM_SET_PG_CONNECTION_SECRET_NAME=''
HELM_SET_PG_CONNECTION_SECRET_KEYNAME=''

#REDIS_BITNAMI_CHART_VERSION="--version 19.0.2"
#MONGO_BITNAMI_CHART_VERSION="--version 15.1.3"
#POSTGRES_BITNAMI_CHART_VERSION="--version 12.12.10"
ADMIN_EMAIL=''
ADMIN_PASSWORD=''

# if the standard setup file exists take defaults from that
if [[ -f ~/.tyk-sandbox ]]; then
  . ~/.tyk-sandbox
else
  SBX_LICENSE=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJhbGxvd2VkX25vZGVzIjoiNjk0NWIwMWMtZWU5NS00YWZmLTQ1ZWEtOTkxMTgzZjZlNWY2LDQwMTlmZWY0LTM5NzktNDJiZi00ZDFmLTAxMTFkMGUxMDUwMCw1Y2E4NjhmNC1iMzAyLTQyMjUtNmY5Zi1kNTIwNjllOGIyMzQsNjI5NWFiZjktYTNmOC00Y2RjLTVmMDQtY2I4MjRiMDhhMDU5LGRlOWYzMjAxLTdkMTUtNDVhYS03NDE1LTEzZmVhYjEzY2U3ZSxmMjdiZGFlMi05MDUwLTRmMGQtNTIxMy0xZWI0YjI3YjAyOGEsOTVjMGY2YzMtYzFjNS00OGJmLTUzNDktMTY3NmNiOWM5Y2U0LGUzMjYxYjRiLWJlODctNDVhZi03NzhiLWViYTViMDQ5YmE3ZCwzNWE2NjYxMi1hYjgwLTQ0MTktNDFhNS01NmZmZmZiMjYxN2EsMmFlYjJkODEtYjE3MC00MTNiLTUzYjEtOTA5NTE0NTRhZTRiIiwiZXhwIjoxNzQ2NjYyMzk5LCJoaWQiOiJwZXRlci5zIiwiaWF0IjoxNzQ0MDIwMjQ3LCJsaWNlbnNlX3R5cGUiOiJpbnRlcm5hbCIsIm93bmVyIjoiNjFjY2U2MmMxMjFjYTEwMDAxOGJiMTkwIiwic2NvcGUiOiJtdWx0aV90ZWFtLHJiYWMsZ3JhcGgsZmVkZXJhdGlvbixzdHJlYW1zLHRyYWNrIiwidiI6IjIifQ.YtjKFa_m13RNDHloUBMcYGB1TG82LIX9XOmSEhYkIQVTPKxvV0h2oZRuYMui9oDyauzEcrc7jzU9bZAvL4acXX74D7oq_f0_rV_rWBR9abQlEO5wZ2RGaLn2qO-XiA-vYQtzXiNfKDFMLrAOmLCHuH8zDkg4Rs4mBJ9d8MQ8EbcD_pFXpgVsP7haEWgLnojEFzeN9HoDTc2JnXV3UmFi67KN8OwcMczmERNzDPzTa12JhC37R029SA6dru2Q0BzGa_P8VoIMFvoLtXCHExrUAAbH_ZvA_6wF-0As4JN4LsQ0u4I5HZ4ELSt0kdgX7GbO7QiMNWmlvvytQwKDRmgQog
  SBX_MDCB_LICENSE=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJTS1UiOiJUeWstTURDQi1FTlQiLCJleHAiOjE3NjU1ODM5OTksImhpZCI6InBldGVyLnMiLCJsaWNlbnNlX3R5cGUiOiJpbnRlcm5hbCIsIm93bmVyIjoiNjZiNjNiNDZlM2M0ZDUwMDAxNzM5NGIyIn0.gKvhBXt3wM5_zyrqYTX4zxCbdlqUmpjEooy9_SB8Bq5HGfS6hE6jFXVzJNbh3xTrXMEx3EUKJTa0oZI2So1ojEJUARrNy6w9iP03yu1rvoFs3zz_7m2RHWOBiHkL_xI7eXrt0OKXMDTapGixEJoOoEeRzQkz_OZU4CDrNKbgefjNuwq6wWxdV4Yd7P59H25MvnKDuj_XgOIqPcxLKDaF1rODT_1zCyEW4IvGRJd5EIOXjkDMrFb-K-KWyQr9isfNy0VSSsSeYZ1FiXGW-dMu_LOOiDQ1oJqDVsrBBjymf3Pf1kvcUQkvCey2lWJscZgFNRKkIU4mmUzT1MHIQIE_Vw
fi

# take the ADMIN_EMAIL and ADMIN_PASSWORD from ~/.tyk-sandbox if defined
if [[ -z $SBX_USER ]]; then
  ADMIN_EMAIL=user@admin.com
  ADMIN_PASSWORD=ABC-123
else
  ADMIN_EMAIL=$SBX_USER
  ADMIN_PASSWORD=$(echo -n $SBX_PASSWORD | base64 -d)
fi

IP=$(minikube ip)

function help {
  typeset name
  name=$SCRIPTNAME
  echo "[USAGE]: $name create -v <tyk version> -t <namespace description>"
  echo "      Create a tyk instance in a namespace sandbox with the version given as a tag with -v"
  echo "      -c The number of control plane gateway replicas to run"
  echo "      -C The chart to deploy. Defaults to tyk-stack"
  echo "         Supported charts are:"
  echo "         tyk-stack"
  echo "         tyk-control-plane"
  echo "      -D The size of the allocated Mongo or PG storage in Gi (default: ${HSBX_MAIN_DB_SIZE}Gi)"
  echo "      -E A file to read environment variables from and add them all deployments"
  echo "      -h Enable https on gateways"
  echo "      -N Use the given namespace name rather than the next available sandbox"
  echo "         Useful when there's a need to import apis and policy YAML with set namespace"
  echo "      -p Deploy with postgres not mongo"
  echo "      -P Deploy with EDP. (Implies -p)"
  echo "      -R The size of the allocated redis control or data plane storage in Gi (default: ${HSBX_REDIS_DB_SIZE}Gi)"
  echo "      -t Description of the sandbox namespace"
  echo "      -V values.yaml file to use instead of other options. Note this overrides all other Tyk options"
  echo "      -v Version tag. The file $VERSIONFILE contains the versions of each product used"
  echo "$name delete <sandbox namespace...>"
  echo "      Delete the sandbox namespace given as a tag and all resources in it"
  echo "$name get <sandbox namespace...> [chart|release|description|dashboard|gateway|redis|redis-password|redis-port|key|mdcb|mongo|postgres|orgid|values]"
  echo "      Print the requested detail in a way that's useful in another script"
  echo "      Only 'values' is currently implemented"
  echo "$name logs <sandbox namespace...> <pod part name>"
  echo "      Tails the logs of the first pod that matches 'pod part name' in the namespace"
  echo "$name info <sandbox namespace...>"
  echo "      Print info detailed info on sandbox namespaces"
  echo "$name shell <sandbox namespace...> <pod part name>"
  echo "      Spawns a shell into the pod. Mostly they are now distroless but the bastion can be used"
  echo "$name version <sandbox namespace...>"
  echo "      Shows the image version in each deployment in the namespace"
}

function listPods {
  kubectl get pods -n $NAMESPACE
}

# Wait for something to be ready
function waitResourceReady {
  typeset resourcetype
  typeset waitfor
  resourcetype=$1
  waitfor=$2
  if [[ -n $waitfor ]]; then
    if kubectl get $resourcetype --no-headers=true -n $NAMESPACE $waitfor > /dev/null 2>&1; then
      echo -n "[INFO]Waiting for $resourcetype $NAMESPACE:$waitfor to be ready."
      while [[ $( kubectl get $resourcetype --no-headers=true -n $NAMESPACE $waitfor | awk -F '[ /]+' 'BEGIN{allup=0} {up=$2 - $3; if (up != 0) {allup=up}}; END{print allup}' ) -ne 0 ]]; do
        echo -n .
        sleep 5
      done
    else
      echo "[FATAL]Cannot find a $resourcetype matching '$2'"
      exit 1
    fi
  fi
  echo " done"
}

# Wait for a deployment to be ready.
function waitDeploymentReady {
  typeset deploymentName
  for deploymentName in "$@"; do
    waitResourceReady deployment "$deploymentName"
  done
}

# Wait for a deployment to be ready.
function waitStatefulSetReady {
  typeset statefulsetName
  for statefulsetName in "$@"; do
    waitResourceReady statefulset "$statefulsetName"
  done
}

# find the next namespace index that's unused
function nextFreeNamespace {
  typeset existing
  typeset i
  existing=$(kubectl get namespaces --selector=$NAMESPACE_SELECTOR_LABEL --no-headers=true 2>/dev/null | awk '{print $1}')
  for i in $(seq 1 1000); do
    test="hsandbox-$i"
    if ! echo $existing | grep -qw $test; then
      echo $i
      break
    fi
  done
}

function getAllSandboxes {
  kubectl get namespaces --selector=$NAMESPACE_SELECTOR_LABEL --no-headers=true 2>/dev/null | awk '{print $1}' | xargs
}

# allow the shortcut of using 1 to mean hsandbox-1 on the commandline
function getNamespaceNames {
  typeset namespaces
  typeset namespace
  namespaces=''
  for namespace in $*; do
    if ! namespaceExists $namespace; then
      if ! echo $namespace | grep -q hsandbox- ; then
        namespaces="$namespaces hsandbox-$namespace"
      else
        namespaces="$namespaces $namespace"
      fi
    else
      namespaces="$namespaces $namespace"
    fi
  done
  echo $namespaces
}

# read the versions file and create an array of associated versions
# isolated to keep IFS from leaking
function loadVersions {
  typeset line
  typeset IFS
  typeset gwVers
  typeset dshbVers
  typeset pumpVers
  typeset TIBvers
  typeset syncVers
  typeset MDCBvers
  typeset EDPvers
  typeset version
  line=$1
  IFS=,
  echo "$line" | read version gwVers dshbVers pumpVers TIBvers syncVers MDCBvers EDPvers
  export HSBX_GATE_PLUGIN_DIR="$gwVers"
  if [[ ! -d $HOME/.tyk/plugins/$HSBX_GATE_PLUGIN_DIR ]]; then
    mkdir -p $HOME/.tyk/plugins/$HSBX_GATE_PLUGIN_DIR
  fi
  export HSBX_GATE_VERS="v${gwVers%%-1}"
  if echo $HSBX_GATE_VERS | grep -q ee; then
    HSBX_GATE_EE='-ee'
  else
    HSBX_GATE_EE=''
  fi
  HSBX_GATE_VERS=$(echo $HSBX_GATE_VERS | sed 's/ee-//g')
  HSBX_GATE_VERS=$(echo $HSBX_GATE_VERS | sed 's/~/-/g')
  HSBX_DASH_VERS="v${dshbVers%%-1}"
  HSBX_PUMP_VERS="v${pumpVers%%-1}"
  if [[ $HSBX_ENABLE_DEVPORTAL == "true" ]]; then
    HSBX_DEVPORTAL_VERS="v${EDPvers%%-1}"
  fi
  if [[ $HSBX_CHART == 'tyk-control-plane' ]]; then
    HSBX_MDCB_VERS="v${MDCBvers%%-1}"
  fi
}

function getMinikubeIP {
  minikube profile list -l 2> /dev/null | awk '/'$CLUSTER'/ {print $8}'
}

function namespaceExists {
  typeset namespace
  typeset ns
  namespace=$1
  for ns in $(kubectl get namespaces --no-headers=true | awk '{print $1}'); do
    if [[ "$ns" == $namespace ]]; then
      return 0
    fi
  done
  return 1
}

# create a namespace for the sandbox and save labels that say what it's for etc.
# these labels are used internally and are also helpful for remembering why you created the sandbox
function createNamespace {
  typeset configYAML
  configYAML=$(mktemp /tmp/configYAML.yaml.XXXX)
  if ! namespaceExists $NAMESPACE; then
    echo "[INFO]kubectl create ns $NAMESPACE"
    kubectl create ns $NAMESPACE
    echo "[INFO]kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR_LABEL $EXTRA_NAMESPACE_LABELS"
    kubectl label ns $NAMESPACE $NAMESPACE_SELECTOR_LABEL $EXTRA_NAMESPACE_LABELS
    # setup config map in the new namespace with the details of the deployment
    echo "apiVersion: v1" > $configYAML
    echo "data:" >> $configYAML
    if [[ -n $sandboxVersion ]]; then
      echo "  HSBX_VERSION: $sandboxVersion" >> $configYAML
    fi
    if [[ -n $HSBX_GATE_VERS ]]; then
      echo "  HSBX_GW: $HSBX_GATE_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_DASH_VERS ]]; then
      echo "  HSBX_DB: $HSBX_DASH_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_PUMP_VERS ]]; then
      echo "  HSBX_PMP: $HSBX_PUMP_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_MDCB_VERS ]]; then
      echo "  HSBX_MDCB: $HSBX_MDCB_VERS" >> $configYAML
    fi
    if [[ -n $HSBX_DEVPORTAL_VERS ]]; then
      echo "  HSBX_DEVPORTAL: $HSBX_DEVPORTAL_VERS" >> $configYAML
    fi
    echo "  HSBX_CHART: $HSBX_CHART" >> $configYAML
    if [[ $HSBX_CHART == 'tyk-stack'  || $HSBX_CHART == 'tyk-control-plane' ]]; then
      echo "  HSBX_DATABASE: $HSBX_DATABASE" >> $configYAML
    fi
    echo "  HSBX_DESCRIPTION: \"$HSBX_DESCRIPTION\"" >> $configYAML
    echo "  HSBX_CHART: \"$HSBX_CHART\"" >> $configYAML
    echo "  HSBX_GATE_USE_HTTPS: \"$HSBX_GATE_USE_HTTPS\"" >> $configYAML
    echo "kind: ConfigMap" >> $configYAML
    echo "metadata:" >> $configYAML
    echo "  namespace: \"$NAMESPACE\"" >> $configYAML
    echo "  name: sandbox-details" >> $configYAML
    kubectl apply -f $configYAML -n $NAMESPACE
    echo "[INFO]Created namespace '$NAMESPACE'"
  fi
  rm -f $configYAML
}

function setupControlPlaneBootstrapSecrets {
  setupTykSystemSecrets
  setupAdminAccountSecrets
}


# setup secrets like licences and the Admin secret
function setupTykSystemSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_TYK_K8S_SECRETS; then
    kubectl create secret generic $HSBX_TYK_K8S_SECRETS -n $NAMESPACE \
      --from-literal=APISecret=$HSBX_GATE_SECRET \
      --from-literal=AdminSecret=$HSBX_ADMIN_SECRET \
      --from-literal=DashLicense=$SBX_LICENSE \
      --from-literal=DevPortalLicense=$SBX_LICENSE \
      --from-literal=OperatorLicense=$SBX_LICENSE \
      --from-literal=securitySecret=$HSBX_GATE_SECRET \
      --from-literal=MDCBLicense=$SBX_MDCB_LICENSE
  fi
}

# setup secrets for the dashboard admin user
function setupAdminAccountSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_ADMIN_ACCOUNT_SECRETS; then
    kubectl create secret generic $HSBX_ADMIN_ACCOUNT_SECRETS -n $NAMESPACE \
      --from-literal=adminUserFirstName=Admin \
      --from-literal=adminUserLastName=User \
      --from-literal=adminUserEmail=$ADMIN_EMAIL \
      --from-literal=adminUserPassword=$ADMIN_PASSWORD
  fi
}

# setup secrets for the remote control plane
function setupRemoteControlPlaneSecrets {
  typeset orgid
  typeset adminKey
  orgid=$(getOrgID $HSBX_REMOTE_CONTROL_PLANE_NAMESPACE)
  adminKey=$(getAdminUserKey $HSBX_REMOTE_CONTROL_PLANE_NAMESPACE)
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_REMOTE_CONTROL_PLANE_SECRETS; then
    kubectl create secret generic $HSBX_REMOTE_CONTROL_PLANE_SECRETS -n $NAMESPACE \
      --from-literal=orgId=$orgid \
      --from-literal=userApiKey=$adminKey \
      --from-literal=groupID=$NAMESPACE
  fi
}

# deploy redis
function deployRedis {
  if ! helm list -n $NAMESPACE | grep -qw tyk-redis; then
    echo "[INFO]Deploying Redis from bitnami/redis chart $REDIS_BITNAMI_CHART_VERSION"
    helm upgrade tyk-redis bitnami/redis -n $NAMESPACE --install $REDIS_BITNAMI_CHART_VERSION \
      --set image.repository=bitnamilegacy/redis \
      --set master.persistence.size=${HSBX_REDIS_DB_SIZE}Gi \
      --set replica.persistence.size=${HSBX_REDIS_DB_SIZE}Gi \
      --set replica.replicaCount=$HSBX_REDIS_REPLICAS \
      --set master.service.type=NodePort \
      --set replica.service.type=NodePort > /dev/null
  fi
}

function deployBastion {
  echo "[INFO]Creating bastion pod for shell access and debugging"
  applyYAMLtemplate bastion.yaml bastion-svc.yaml
}

# spawn a shell in a pod
function runShell {
  typeset podPartName
  typeset pod
  typeset adminKey
  typeset orgid
  typeset https
  typeset TYK_DSHB; typeset TYK_GW
  for podPartName in $*
  do
    echo "[INFO]Creating shell for $podPartName"
    for pod in $(getPodNames $podPartName)
    do
      echo "[INFO]Starting /bin/sh in $pod"
      echo "[INFO]kubectl exec $pod -n $NAMESPACE -it -- /bin/sh"
      if echo $pod | grep -q bastion; then
        # the bastion host is RHEL and setup as I want it so just create a shell
        # but populate the environment with handy values
        adminKey=$(getAdminUserKey)
        orgid=$(getOrgID)
        TYK_DSHB=$(getDashboardInternalURL)
        TYK_GW=$(getGatewayInternalURL)
        echo "[INFO]Setting TYK_KEY=$adminKey TYK_ORG=$orgid TYK_DSHB=$TYK_DSHB TYK_GW=$TYK_GW for convenience"
        kubectl exec $pod -n $NAMESPACE -it -- env TYK_KEY=$adminKey TYK_ORG=$orgid TYK_DSHB=$TYK_DSHB TYK_GW=$TYK_GW /bin/bash
      else
        # if ncurses-base isnt installed then TERM isn't recognised
        # I found it was installed in some images but not others
        # echo "[INFO]Checking for ncurses-base in $pod"
        if ! kubectl exec $pod -n $NAMESPACE -- test -d /lib/terminfo >/dev/null 2>&1; then
          echo "[INFO]Installing ncurses-base to provide terminal types to the shell"
          kubectl exec $pod -n $NAMESPACE -- apt-get update > /dev/null 2>&1
          kubectl exec $pod -n $NAMESPACE -- apt install ncurses-base -y > /dev/null 2>&1
        fi
        kubectl exec $pod -n $NAMESPACE -it -- /bin/sh
      fi
    done
  done
}

# fetch the redis password from the tyk-redis secret, decode it and save it into REDIS_PASSWORD
function getRedisPassword {
  kubectl get secret --namespace $NAMESPACE tyk-redis -o jsonpath="{.data.redis-password}" | base64 -d
}

# deploy postgres
function deployPostgres {
  if ! helm list -n $NAMESPACE | grep -qw tyk-postgres; then
    echo "[INFO]Deploying Postgres from bitnami/postgresql chart $POSTGRES_BITNAMI_CHART_VERSION"
    helm upgrade tyk-postgres bitnami/postgresql -n $NAMESPACE --install $POSTGRES_BITNAMI_CHART_VERSION \
      --set image.repository=bitnamilegacy/postgresql \
      --set "auth.database=tyk_analytics" \
      --set primary.persistence.size=${HSBX_MAIN_DB_SIZE}Gi \
      --set readReplicas.persistence.size=${HSBX_MAIN_DB_SIZE}Gi \
      --set primary.service.type=NodePort > /dev/null
    # save the helm options for when installing Tyk
    HELM_SET_PG_CONNECTION_SECRET_NAME="--set global.postgres.connectionStringSecret.name=$POSTGRES_SECRETS"
    HELM_SET_PG_CONNECTION_SECRET_KEYNAME="--set global.postgres.connectionStringSecret.keyName=postgresConnectionString"
  fi
}

function postgresSetupSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $POSTGRES_SECRETS; then
    POSTGRES_PASSWORD=$(getPostgressPassword)
    POSTGRES_CONNECTION_STRING="user=postgres password=$POSTGRES_PASSWORD database=tyk_analytics host=tyk-postgres-postgresql port=5432"
    kubectl create secret generic $POSTGRES_SECRETS -n $NAMESPACE --from-literal=postgresConnectionString="$POSTGRES_CONNECTION_STRING"
  fi
}

function getPostgressPassword {
  kubectl get secret --namespace $NAMESPACE tyk-postgres-postgresql -o jsonpath="{.data.postgres-password}" | base64 -d
}

# deploy mongodb
function deployMongodb {
  if ! helm list -n $NAMESPACE | grep -qw tyk-mongo; then
    echo "[INFO]Deploying Mongodb from bitnami/mongdb chart $MONGO_BITNAMI_CHART_VERSION"
    helm upgrade tyk-mongo bitnami/mongodb -n $NAMESPACE --install $MONGO_BITNAMI_CHART_VERSION \
      --set image.repository=bitnamilegacy/mongodb \
      --set persistence.size=${HSBX_MAIN_DB_SIZE}Gi \
      --set backup.cronjob.storage.size=${HSBX_MAIN_DB_SIZE}Gi \
      --set service.type=NodePort > /dev/null
    # save the helm options for when installing Tyk
    HELM_SET_MONGO_DRIVER="--set global.mongo.driver=mongo-go"
    HELM_SET_MONGO_URL_SECRET_NAME="--set global.mongo.connectionURLSecret.name=$MONGODB_SECRETS"
    HELM_SET_MONGO_URL_SECRET_KEYNAME="--set global.mongo.connectionURLSecret.keyName=mongoUrl"
  fi
}

function getMongoInternalURL {
    MONGODB_ROOT_PASSWORD=$(getMongoPassword)
    echo "mongodb://root:$MONGODB_ROOT_PASSWORD@tyk-mongo-mongodb.$NAMESPACE.svc:27017/tyk_analytics?authSource=admin"
}

function getMongoExternalURL {
  typeset ip; ip=$1
  typeset port; port=$2
  MONGODB_ROOT_PASSWORD=$(getMongoPassword)
  echo "mongodb://root:$MONGODB_ROOT_PASSWORD@$ip:$port/tyk_analytics?authSource=admin"
}

# retrieve the mongodb secrets from the MONGODB_SECRETS decode and save into MONGODB_ROOT_PASSWORD and MONGODB_URL
function mongoSetupSecrets {
  if ! kubectl get secret -n $NAMESPACE | grep -qw $MONGODB_SECRETS; then
    if ! kubectl get secret -n $NAMESPACE | grep -qw $MONGODB_SECRETS; then
      kubectl create secret generic $MONGODB_SECRETS --from-literal=mongoUrl=$(getMongoInternalURL) -n $NAMESPACE
    fi
  fi
}

function getMongoPassword {
  kubectl get secret --namespace $NAMESPACE tyk-mongo-mongodb -o jsonpath="{.data.mongodb-root-password}" | base64 -d
}

# setup Devportal secrets 
# adminUserEmail in this secret is ignored by the bootstrap and default@example.com is used instead
# BUT you can use the below in the helm command to set the admin email for portal
# --set global.adminUser.email=$ADMIN_EMAIL
function setupDevPortalSecrets {
  HSBX_DEVPORTAL_PORTAL_SECRET=secrets-$(getHelmRelease)-tyk-dev-portal
  if ! kubectl get secret -n $NAMESPACE | grep -qw $HSBX_DEVPORTAL_PORTAL_SECRET; then
    kubectl create secret generic $HSBX_DEVPORTAL_PORTAL_SECRET -n $NAMESPACE \
      --from-literal=DevPortalDatabaseConnectionString="$POSTGRES_CONNECTION_STRING" \
      --from-literal=adminUserEmail=$ADMIN_EMAIL \
      --from-literal=adminUserPassword=$ADMIN_PASSWORD \
      --from-literal=DevPortalLicense=$SBX_LICENSE
      # these cant be used until TT-14957 is fixed
      #    --from-literal=adminUserFirstName=Admin_first \
      #    --from-literal=adminUserLastName=Admin_last \
  fi
}

# install the tyk repo and update
function installTykHelmRepo {
  if ! helm repo list | grep -wq tyk-helm; then
    helm repo add tyk-helm https://helm.tyk.io/public/helm/charts/
  fi
  helm repo update
}

# retrieve the orgid and admin key from redis and save them to the configmap 'sandbox-details' for reporting
function saveOrgAndAdminKey {
  typeset redisPassword
  typeset redisPort
  typeset adminRedisKey
  typeset adminAccessKey
  typeset orgID
  redisPassword=$(getRedisPassword)
  redisPort=$(getRedisPort)
  adminRedisKey=$(echo keys tyk-admin-api\* | REDISCLI_AUTH=$redisPassword redis-cli --raw -h $IP -p $redisPort | head -1)
  adminAccessKey=$(echo get $adminRedisKey | REDISCLI_AUTH=$redisPassword redis-cli --raw -h $IP -p $redisPort | jq -r .UserData.access_key)
  orgID=$(echo get $adminRedisKey | REDISCLI_AUTH=$redisPassword redis-cli --raw -h $IP -p $redisPort | jq -r .UserData.org_id)
  kubectl get configmap sandbox-details -n $NAMESPACE -o yaml | yq '.data.HSBX_ADMIN_KEY = "'$adminAccessKey'"' | kubectl apply -f -
  kubectl get configmap sandbox-details -n $NAMESPACE -o yaml | yq '.data.HSBX_ORGID = "'$orgID'"' | kubectl apply -f -
}

function getPodNames {
  typeset podname
  podname="$1"
  kubectl get pods -n $NAMESPACE | awk '/'$podname'/ {print $1}' | xargs
}

# Process the YAML with envsubst to substitute environment variables into them
# All exported environment varables are available to envsubst but these are the main ones
# HSBX_GATE_VERS which has the gateway version. This is used to pull the gateway docker image
# HSBX_GATE_EE which contains nothing for non-EE gateways and "-ee" for EE gateways
# HSBX_DASH_VERS which has the dashboard version. This is used to pull the dashboard docker image
# HSBX_PUMP_VERS which has the pump version. This is used to pull the pump docker image
# HSBX_MDCB_VERS which has the MDCB version. This is used to pull the MDCB docker image
# HSBX_EDP_VERS which has the EDP version. This is used to pull the EDP docker image
# HSBX_NS which is the namespace for the pods etc.
function applyYAMLtemplate {
  typeset YAMLfile
  typeset tmpYamlFile
  for YAMLfile in $*; do
    YAMLfile=$(basename $YAMLfile)
    tmpYamlFile=$(mktemp /tmp/XXXXX-$YAMLfile)
    if [[ -f $YAMLDIR/$YAMLfile ]]; then
      cat $YAMLDIR/$YAMLfile | envsubst > $tmpYamlFile
      if [[ -n $ENV_VAR_FILE ]]; then
        if grep -qw 'kind: Deployment' $tmpYamlFile; then
          addGlobalEnvVars $tmpYamlFile
        fi
      fi
      kubectl apply -n $NAMESPACE -f $tmpYamlFile
    fi
    rm -f $tmpYamlFile
  done
}

function runHelm {
  if [[ -z $HSBX_VALUES_FILE ]]; then
    echo "[INFO]Deploying Tyk from chart tyk-helm/$HSBX_CHART onto namespace $NAMESPACE using release named $HELM_TYKSTACK_RELEASE_NAME"
    if [[ $HSBX_CHART == 'tyk-control-plane' ]]; then
      HELM_SET_TYK_MDCB_SERVICE="--set tyk-mdcb.mdcb.service.type=$HELM_TYK_MDCB_SERVICE_TYPE"
      HELM_SET_MDCB_LICENCE="--set tyk-mdcb.mdcb.useSecretName=$HSBX_TYK_K8S_SECRETS"
      HELM_RELEASE_NAME=$HELM_TYKCONTROLPLANE_RELEASE_NAME
    elif [[ $HSBX_CHART == 'tyk-stack' ]]; then
      HELM_RELEASE_NAME=$HELM_TYKSTACK_RELEASE_NAME
    fi
    if [[ $HSBX_CHART == 'tyk-control-plane' || $HSBX_CHART == 'tyk-stack' ]]; then
      helm upgrade $HELM_RELEASE_NAME tyk-helm/$HSBX_CHART -n $NAMESPACE \
        --install \
        --set global.adminUser.useSecretName=$HSBX_ADMIN_ACCOUNT_SECRETS \
        --set global.adminUser.email=$ADMIN_EMAIL \
        --set global.secrets.useSecretName=$HSBX_TYK_K8S_SECRETS \
        --set global.components.operator=false \
        --set global.components.devPortal=$HELM_TYK_DEVPORTAL_ENABLED \
        --set global.storageType=$HELM_GLOBAL_STORAGETYPE \
        --set global.redis.addrs="{tyk-redis-master.$NAMESPACE.svc:6379}" \
        --set global.redis.passSecret.name=tyk-redis \
        --set global.redis.passSecret.keyName=redis-password \
        --set global.tls.gateway=$HSBX_GATE_USE_HTTPS \
        --set tyk-dashboard.dashboard.image.tag=$HSBX_DASH_VERS \
        --set tyk-dashboard.dashboard.service.type=$HELM_TYK_DASHBOARD_SERVICE_TYPE \
        --set tyk-dashboard.dashboard.auditLogs.enabled=true \
        --set tyk-dashboard.dashboard.auditLogs.enableDetailedRecording=true \
        --set tyk-dashboard.dashboard.auditLogs.type=db \
        $HELM_SET_MONGO_DRIVER \
        $HELM_SET_MONGO_URL_SECRET_NAME \
        $HELM_SET_MONGO_URL_SECRET_KEYNAME \
        $HELM_SET_PG_CONNECTION_SECRET_NAME \
        $HELM_SET_PG_CONNECTION_SECRET_KEYNAME \
        $HELM_SET_TYK_DEVPORTAL_USESECRETNAME \
        $HELM_SET_TYK_DEVPORTAL_SERVICE \
        $HELM_SET_TYK_DEVPORTAL_IMAGE_TAG \
        $HELM_SET_TYK_DEVPORTAL_DATABASE_DIALECT \
        $HELM_SET_TYK_DASHBOARD_EXTRAENVS \
        $HELM_SET_TYK_GATEWAY_EXTRAENVS \
        $HELM_SET_TYK_PUMP_EXTRAENVS \
        $HELM_SET_TYK_DEVPORTAL_EXTRAENVS \
        $HELM_SET_TYK_MDCB_SERVICE \
        $HELM_SET_MDCB_LICENCE \
        --set tyk-gateway.gateway.image.tag=$HSBX_GATE_VERS \
        --set tyk-gateway.gateway.service.type=$HELM_TYK_GATEWAY_SERVICE_TYPE \
        --set tyk-gateway.gateway.control.type=$HELM_TYK_GATEWAY_CONTROL_TYPE \
        $HELM_SET_TYK_GATEWAY_REPLICACOUNT \
        --set tyk-pump.pump.image.tag=$HSBX_PUMP_VERS \
        --set tyk-pump.pump.service.type=$HELM_TYK_PUMP_SERVICE_TYPE  > /dev/null
    elif [[ $HSBX_CHART == 'tyk-data-plane' ]]; then
      exit 0
    fi
  else
    echo "[INFO]Deploying Tyk from chart tyk-helm/$HSBX_CHART onto namespace $NAMESPACE using values from $HSBX_VALUES_FILE"
    helm upgrade $HELM_RELEASE_NAME tyk-helm/$HSBX_CHART -n $NAMESPACE \
      --install \
      -f $HSBX_VALUES_FILE
  fi
}

# return the description of the sandbox which is stored in sandbox-details when the sandbox was created
function getDescription {
  kubectl get configmap sandbox-details -n $NAMESPACE -o json | jq -r .data.HSBX_DESCRIPTION
}

# return the chart used to create the sandbox
function getChart {
  typeset namespace
  namespace=$NAMESPACE
  if [[ $# > 0 ]]; then
    namespace="$1"
  fi
  kubectl get configmap sandbox-details -n $namespace -o json | jq -r .data.HSBX_CHART
}

# return the chart used to create the sandbox
function getEDPversion {
  kubectl get configmap sandbox-details -n $NAMESPACE -o json | jq -r .data.HSBX_DEVPORTAL
}

function getAdminUserKey {
  typeset namespace
  namespace=$NAMESPACE
  if [[ $# > 0 ]]; then
    namespace="$1"
  fi
  kubectl get configmap sandbox-details -n $namespace -o json | jq -r .data.HSBX_ADMIN_KEY
}

function getHelmRelease {
  if [[ -n $HSBX_CHART ]]; then
    HSBX_CHART=$(getChart)
  fi
  case $HSBX_CHART in
    tyk-stack)
      echo $HELM_TYKSTACK_RELEASE_NAME
      ;;
    tyk-control-plane)
      echo $HELM_TYKCONTROLPLANE_RELEASE_NAME
      ;;
    tyk-data-plane)
      echo $HELM_DATAPLANE_RELEASE_NAME
      ;;
  esac
}

function setHelmRelease {
  HELM_RELEASE_NAME=$(getHelmRelease)
}
    
function getOrgID {
  typeset namespace
  namespace=$NAMESPACE
  if [[ $# > 0 ]]; then
    namespace="$1"
  fi
  kubectl get configmap sandbox-details -n $namespace -o json | jq -r .data.HSBX_ORGID
}

function getHTTPS {
  kubectl get configmap sandbox-details -n $NAMESPACE -o json | jq -r .data.HSBX_GATE_USE_HTTPS
}

function getDashboardPort {
  kubectl get svc -n $NAMESPACE dashboard-svc-$HELM_RELEASE_NAME-tyk-dashboard --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getDashboardInternalURL {
  typeset namespace
  namespace=$NAMESPACE
  if [[ $# > 0 ]]; then
    namespace="$1"
  fi
  echo "http://dashboard-svc-$HELM_RELEASE_NAME-tyk-dashboard.$namespace.svc:3000"
}

function getGatewayInternalURL {
  typeset namespace
  namespace=$NAMESPACE
  if [[ $# > 0 ]]; then
    namespace="$1"
  fi
  typeset proto=http
  if [[ $(getHTTPS) == "true" ]]; then
    proto=https
  fi
  echo "$proto://gateway-svc-$HELM_RELEASE_NAME-tyk-gateway.$namespace.svc:8080"
}

function getPortalPort {
  kubectl get svc -n $NAMESPACE dev-portal-svc-$HELM_RELEASE_NAME-tyk-dev-portal --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getGatewayPort {
  kubectl get svc -n $NAMESPACE gateway-svc-$HELM_RELEASE_NAME-tyk-gateway --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getPostgresPort {
  kubectl get svc -n $NAMESPACE tyk-postgres-postgresql --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getMongoPort {
  kubectl get svc -n $NAMESPACE tyk-mongo-mongodb --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getRedisPort {
  kubectl get svc -n $NAMESPACE tyk-redis-master --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getMDCBPort {
  kubectl get svc -n $NAMESPACE mdcb-svc-$HELM_RELEASE_NAME-tyk-mdcb --no-headers=true | awk -F '[:/ ]+' '{print $6}'
}

function getMDCBHealthPort {
  kubectl get svc -n $NAMESPACE mdcb-svc-$HELM_RELEASE_NAME-tyk-mdcb --no-headers=true | awk -F '[:/ ]+' '{print $8}'
}

function getMDCBServce {
  echo "mdcb-svc-$HELM_RELEASE_NAME-tyk-mdcb.$NAMESPACE.svc:9091"
}

# check if we're on Mongodb or Postgresql
function getDatabaseType {
  HSBX_DATABASE=$(kubectl get configmap sandbox-details -n $NAMESPACE -o json | jq -r .data.HSBX_DATABASE)
}

# the mongo shell can be called 'mongo' or 'mongosh' so check for both
function checkMongoShellInstalled {
  if [[ -z $MONGOSHELL ]]; then
    if ! which mongo >/dev/null; then
      alias mongo=mongosh
      MONGOSHELL=mongosh
      if ! which mongosh > /dev/null; then
        echo "[WARN]Mongo shell 'mongo' and 'mongosh' are not installed. Will not be able to mongo data"
      fi
    else
      MONGOSHELL=mongo
    fi
  fi
}

# report the tyk versions saved in the namespace configmap sandbox-details when it was created
function showTykVersions {
  typeset key; typeset value; typeset report; typeset sandboxDetails; typeset description
  sandboxDetails=$(kubectl get configmap sandbox-details -n $NAMESPACE -o json | jq -r .data)
  report=''
  for key in HSBX_VERSION HSBX_CHART HSBX_DATABASE HSBX_DB HSBX_GW HSBX_DEVPORTAL HSBX_PMP HSBX_MDCB; do
    value=$(echo $sandboxDetails | jq -r .$key)
    if [[ $value != 'null' ]]; then
      report="$report $key=$value"
    fi
  done
  echo $report
}

# tail the pods logs
function showLogs {
  typeset podPartName
  typeset pod
  podPartName=$1
  pod=$(getPodNames $podPartName | sort | xargs -n 1 | head -1)
  if [[ -n $pod ]]; then
    echo "[INFO]kubectl logs -n $NAMESPACE $pod -f"
    kubectl logs -n $NAMESPACE $pod -f
  else
    echo "[FATAL]'$podPartName' not found in namespace $NAMESPACE"
    kubectl get pods -n $NAMESPACE
  fi
}

function reportSanboxInfo {
  typeset https
  # envs to hold ssh port forwarding details for when we're on EC2
  typeset ssh_dashboard; typeset dashboard_port
  typeset ssh_edp; typeset edp_port
  typeset ssh_gateway; typeset gateway_port
  typeset ssh_mdcb; typeset mdcb_port
  typeset ssh_mongodb; typeset mongodb_port
  typeset ssh_postgres; typeset postgres_port
  typeset ssh_redis; typeset redis_port
  typeset ssh_standalone_gateway; typeset standalone_gateway_port
  typeset ssh_hybrid_gateway; typeset hybrid_gateway_port
  typeset ssh_hybrid_redis; typeset hybrid_redis_port
  typeset display_IP
  HSBX_CHART=$(getChart)
  HELM_RELEASE_NAME=$(getHelmRelease)
  HSBX_HAS_EDP=$(getEDPversion)
  https=$(getHTTPS)
  if [[ $(cat /sys/devices/virtual/dmi/id/board_vendor) == "Amazon EC2" ]]; then
    display_IP=localhost
  else
    display_IP=$IP
  fi
  echo "$NAMESPACE.Description:       $(getDescription)"
  echo "$NAMESPACE.Chart:             $(getChart)"
  if [[ $HSBX_CHART == 'tyk-stack' || $HSBX_CHART == 'tyk-control-plane' ]]; then
    dashboard_port=$(getDashboardPort)
    ssh_dashboard="-L localhost:$dashboard_port:$IP:$dashboard_port"
    echo "$NAMESPACE.dashboard:         http://$display_IP:$dashboard_port/"
    if [[ $HSBX_HAS_EDP != "null" ]]; then
      edp_port=$(getPortalPort)
      ssh_edp="-L localhost:$edp_port:$IP:$edp_port"
      echo "$NAMESPACE.portal:            http://$display_IP:$edp_port/"
    fi
    gateway_port=$(getGatewayPort)
    ssh_gateway="-L localhost:$gateway_port:$IP:$gateway_port"
    if [[ $https == "true" ]]; then
      echo "$NAMESPACE.gateway:           https://$display_IP:$gateway_port/"
    else
      echo "$NAMESPACE.gateway:           http://$display_IP:$gateway_port/"
    fi
    if [[ $HSBX_CHART == 'tyk-control-plane' ]]; then
      mdcb_port=$(getMDCBPort)
      ssh_mdcb="-L localhost:$mdcb_port:$IP:$mdcb_port"
      echo "$NAMESPACE.MDCBport:          $display_IP:$mdcb_port http://$display_IP:$(getMDCBHealthPort)/health"
    fi
    if [[ $HSBX_DATABASE == 'mongo' ]]; then
      checkMongoShellInstalled
      mongodb_port=$(getMongoPort)
      ssh_mongodb="-L localhost:$mongodb_port:$IP:$mongodb_port"
      echo "$NAMESPACE.mongo:             $MONGOSHELL --quiet $(getMongoExternalURL $display_IP $mongodb_port)"
    elif [[ $HSBX_DATABASE == 'postgres' ]]; then
      postgres_port=$(getPostgresPort)
      ssh_postgres="-L localhost:$postgres_port:$IP:$postgres_port"
      echo "$NAMESPACE.postgres:          PGPASSWORD=$(getPostgressPassword) psql --username=$HSBX_PGUSER --dbname=$HSBX_PGDB --host=$display_IP --port=$postgres_port"
    fi
    redis_port=$(getRedisPort)
    ssh_redis="-L localhost:$redis_port:$IP:$redis_port"
    echo "$NAMESPACE.redis:             REDISCLI_AUTH=$(getRedisPassword) redis-cli -h $display_IP -p $redis_port"
    echo "$NAMESPACE.AdminKey:          $(getAdminUserKey)"
    echo "$NAMESPACE.OrgID:             $(getOrgID)"
  elif [[ $HSBX_CHART == "tyk-gateway" ]]; then
    standalone_gateway_port=$(getStandaloneGatewayPort)
    ssh_standalone_gateway="-L localhost:$standalone_gateway_port:$IP:$standalone_gateway_port"
    echo "$NAMESPACE.gateway:   http://$display_IP:$standalone_gateway_port/"
    redis_port=$(getRedisPort)
    ssh_redis="-L localhost:$redis_port:$IP:$redis_port"
    echo "$NAMESPACE.redis:     redis-cli -h $display_IP -p $redis_port"
  elif [[ $HSBX_CHART == "tyk-data-plane" ]]; then
    hybrid_gateway_port=$(getHybridGatewayPort)
    ssh_hybrid_gateway="-L localhost:$hybrid_gateway_port:$IP:$hybrid_gateway_port"
    echo "$NAMESPACE.gateway:           http://$display_IP:$hybrid_gateway_port/"
    hybrid_redis_port=$(getHybridRedisPort)
    ssh_hybrid_redis="-L localhost:$hybrid_redis_port:$IP:$hybrid_redis_port"
    echo "$NAMESPACE.redis:             redis-cli -h $display_IP -p $hybrid_redis_port"
  fi
  if [[ $(cat /sys/devices/virtual/dmi/id/board_vendor) == "Amazon EC2" ]]; then
    # report the ssh command to map the service ports back to localhost
    echo "$NAMESPACE.ssh                $(echo ssh $ssh_dashboard $ssh_edp $ssh_gateway $ssh_mdcb $ssh_mongodb $ssh_postgres $ssh_redis $ssh_standalone_gateway $ssh_hybrid_gateway $ssh_hybrid_redis) <aws hostname>"
  fi
  # if the namespace has the label 'istio-injection=enabled' then report the istio-system services
  if kubectl get ns --show-labels --no-headers=true $NAMESPACE | grep -q $ISTIO_INJECTION_LABEL; then
    echo "Kiali:                        http://$IP:$(kubectl get svc -n istio-system kiali --no-headers=true | awk -F '[:/ ]+' '{print $6}')/"
    echo "Grafana:                      http://$IP:$(kubectl get svc -n istio-system grafana --no-headers=true | awk -F '[:/ ]+' '{print $6}')/"
    echo "Tracing:                      http://$IP:$(kubectl get svc -n istio-system tracing --no-headers=true | awk -F '[:/ ]+' '{print $6}')/"
  fi
}

# Sometimes PersistentVolumeClaim are left when the namespace is deleted.
# Tidy up any in state 'Released'
# This happens most when minikube is stopped and restarted
function tidyReleasedPVCs {
  typeset pvc
  for pvc in $(kubectl get pv --no-headers=true 2>/dev/null | awk '$5=="Released" {print $1}'); do
    echo "[INFO]kubectl delete pv $pvc"
    kubectl delete pv $pvc
  done
}

# reads an file containing normal var=val and converts it into 'extraEnvs' for the helm commandline
function setEnvVars {
  typeset filename
  typeset line
  typeset variable
  typeset value
  filename="$1"
  cat "$filename" | while read -r line; do
    variable=$(echo $line | cut -d= -f1)
    value=$(echo $line | cut -d= -f2)
    # Dashboard first
    HELM_SET_TYK_DASHBOARD_EXTRAENVS="$HELM_SET_TYK_DASHBOARD_EXTRAENVS --set tyk-dashboard.dashboard.extraEnvs[$HELM_TYK_DASHBOARD_EXTRAENVS_NEXT_INDEX].name=$variable"
    HELM_SET_TYK_DASHBOARD_EXTRAENVS="$HELM_SET_TYK_DASHBOARD_EXTRAENVS --set tyk-dashboard.dashboard.extraEnvs[$HELM_TYK_DASHBOARD_EXTRAENVS_NEXT_INDEX].value=$value"
    let HELM_TYK_DASHBOARD_EXTRAENVS_NEXT_INDEX+=1
    # Gateway next
    HELM_SET_TYK_GATEWAY_EXTRAENVS="$HELM_SET_TYK_GATEWAY_EXTRAENVS --set tyk-gateway.gateway.extraEnvs[$HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX].name=$variable"
    HELM_SET_TYK_GATEWAY_EXTRAENVS="$HELM_SET_TYK_GATEWAY_EXTRAENVS --set tyk-gateway.gateway.extraEnvs[$HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX].value=$value"
    let HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX+=1
    # Pump next
    HELM_SET_TYK_PUMP_EXTRAENVS="$HELM_SET_TYK_PUMP_EXTRAENVS --set tyk-pump.pump.extraEnvs[$HELM_TYK_PUMP_EXTRAENVS_NEXT_INDEX].name=$variable"
    HELM_SET_TYK_PUMP_EXTRAENVS="$HELM_SET_TYK_PUMP_EXTRAENVS --set tyk-pump.pump.extraEnvs[$HELM_TYK_PUMP_EXTRAENVS_NEXT_INDEX].value=$value"
    let HELM_TYK_PUMP_EXTRAENVS_NEXT_INDEX+=1
    # Dev Portal next
    HELM_SET_TYK_DEVPORTAL_EXTRAENVS="$HELM_SET_TYK_DEVPORTAL_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX].name=$variable"
    HELM_SET_TYK_DEVPORTAL_EXTRAENVS="$HELM_SET_TYK_DEVPORTAL_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX].value=$value"
    let HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX+=1
  done
}

# Process commands and take actions
if [[ $# -gt 0 ]]; then
  case $1 in 
    create)
      shift
      while getopts :C:c:D:E:hN:PpR:r:t:V:v: arg; do
        case $arg in
          c)
            # the number of gateways to deploy (these are also just gateways in the pro install)
            # defaults to one
            HELM_SET_TYK_GATEWAY_REPLICACOUNT="--set tyk-gateway.gateway.replicaCount=$OPTARG"
            ;;
          C)
            # this is the chart to deploy. Defaults to tyk-stack
            HSBX_CHART=$OPTARG
            ;;
          D)
            # The size of the allocated Mongo or PG storage in GiB
            HSBX_MAIN_DB_SIZE=$(echo $OPTARG | tr -cd 0-9)
            ;;
          E)
            # global environment variable file
            ENV_VAR_FILE=$OPTARG
            if [[ ! -f "$ENV_VAR_FILE" ]]; then
              echo "[FATAL]Cannot read environment variable file: '$ENV_VAR_FILE'"
              exit 1
            fi
            setEnvVars "$ENV_VAR_FILE"
            ;;
          h)
            HSBX_GATE_USE_HTTPS=true
            ;;
          N)
            # specify a particular namespace
            NAMESPACE=$OPTARG
            ;;
          P)
            # deploy devportal so must deploy PG as well then
            HSBX_DATABASE=postgres
            HSBX_ENABLE_DEVPORTAL=true
            ;;
          p)
            # use postgresql not mongodb
            # defaults to mongo without this
            HSBX_DATABASE=postgres
            ;;
          R)
            # the sandbox to use as the remote control plan
            HSBX_REMOTE_CONTROL_PLANE_NAMESPACE=$(getNamespaceNames $OPTARG)
            ;;
          r)
            # The size of the allocated redis storage in GiB
            HSBX_REDIS_DB_SIZE=$(echo $OPTARG | tr -cd 0-9)
            ;;
          t)
            # the description of the namespace or sandbox
            HSBX_DESCRIPTION="$OPTARG"
            ;;
          V)
            # A values.yaml file to use when deploying the Tyk chart
            HSBX_VALUES_FILE=$OPTARG
            if [[ ! -f "$HSBX_VALUES_FILE" ]]; then
              echo "[FATAL]Cannot read values file: '$HSBX_VALUES_FILE'"
              exit 1
            fi
            ;;
          v)
            # the base version to use to look up the versions of each of the products
            sandboxVersion=$OPTARG
            ;;
          :)
            echo "[FATAL]Option -$OPTARG requires an arguement."
            exit 1
            ;;
          \?)
            echo "[FATAL]Invalid option: -$OPTARG"
            exit 1
            ;;
        esac
      done
      if [[ -n $HSBX_REMOTE_CONTROL_PLANE_NAMESPACE ]]; then
        if ! namespaceExists $HSBX_REMOTE_CONTROL_PLANE_NAMESPACE; then
          echo "[FATAL]Control plane namespace '$HSBX_REMOTE_CONTROL_PLANE_NAMESPACE' does not exist"
          exit 1
        fi
        if [[ $(getChart $HSBX_REMOTE_CONTROL_PLANE_NAMESPACE) != 'tyk-control-plane' ]]; then
          echo "[FATAL]Control plane namespace '$HSBX_REMOTE_CONTROL_PLANE_NAMESPACE' is not a tyk-control-plane deployment"
          exit 1
        fi
        # force the chart to tyk-data-plane so we can install a data plane
        HSBX_CHART=tyk-data-plane
      fi
      if [[ -z $NAMESPACE ]]; then
        NAMESPACE=hsandbox-$(nextFreeNamespace)
      fi
      if [[ -z $sandboxVersion ]]; then
        echo "[FATAL]Must specify a release version"
        help
        exit 1
      fi
      if ! namespaceExists $NAMESPACE; then
        HSBX_NS=$NAMESPACE
        export HSBX_NS
        if [[ $HSBX_DATABASE == 'postgres' ]]; then
          if ! echo $sandboxVersion | awk -F. '$1>3{exit 0} $1<4{exit 1}'; then
            echo "[FATAL]Version must be 4 or later to use postgres"
            exit 1
          fi
        fi
        if egrep -q "^$sandboxVersion," $VERSIONFILE; then
          loadVersions $(grep -e "^$sandboxVersion," $VERSIONFILE | head -1)
          echo -n "[INFO]Using Gateway $HSBX_GATE_VERS, Dashboard $HSBX_DASH_VERS, Pump $HSBX_PUMP_VERS"
          if [[ -n $HSBX_MDCB_VERS ]]; then
            echo -n ", MDCB $HSBX_MDCB_VERS"
          fi
          if [[ -n $HSBX_DEVPORTAL_VERS ]]; then
            echo -n ", EDP $HSBX_DEVPORTAL_VERS"
          fi
          echo
        else
          echo "[FATAL]Unable to find '$sandboxVersion' in '$VERSIONFILE'"
          exit 1
        fi
        createNamespace
        # setup redis and save the passwords
        deployRedis
        deployBastion
        if [[ -n $ENV_VAR_FILE ]]; then
          # create a config map to hold the environment variables
          echo "[INFO]Adding environment variables from $ENV_VAR_FILE to configmap sandbox-env-vars"
          kubectl create configmap sandbox-env-vars --from-env-file=$ENV_VAR_FILE -n $NAMESPACE
        fi
        if [[ $HSBX_CHART == 'tyk-stack' || $HSBX_CHART == 'tyk-control-plane' ]]; then
          # setup the secrets that are needed to bootstrap a tyk stack
          setupControlPlaneBootstrapSecrets
          if [[ $HSBX_DATABASE == 'mongo' ]]; then
            deployMongodb
            mongoSetupSecrets
            # wait for the DBs to be available
            waitStatefulSetReady tyk-redis-master tyk-redis-replicas
            waitDeploymentReady tyk-mongo-mongodb
            HELM_GLOBAL_STORAGETYPE="mongo"
          else
            HELM_GLOBAL_STORAGETYPE="postgres"
            deployPostgres
            postgresSetupSecrets
            # wait for the DBs to be available
            waitStatefulSetReady tyk-redis-master tyk-redis-replicas tyk-postgres-postgresql
          fi
          if [[ $HSBX_ENABLE_DEVPORTAL == 'true' ]]; then
            setupDevPortalSecrets
            HELM_TYK_DEVPORTAL_ENABLED=true
            HELM_SET_TYK_DEVPORTAL_USESECRETNAME="--set tyk-dev-portal.useSecretName=$HSBX_DEVPORTAL_PORTAL_SECRET"
            HELM_SET_TYK_DEVPORTAL_IMAGE_TAG="--set tyk-dev-portal.image.tag=$HSBX_DEVPORTAL_VERS"
            HELM_SET_TYK_DEVPORTAL_SERVICE="--set tyk-dev-portal.service.type=NodePort"
            HELM_SET_TYK_DEVPORTAL_DATABASE_DIALECT="--set tyk-dev-portal.database.dialect=postgres"
            # set PORTAL_DISABLE_CSRF_CHECK=true by default
            HELM_SET_TYK_DEVPORTAL_EXTRAENVS="$HELM_SET_TYK_DEVPORTAL_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX].name=PORTAL_DISABLE_CSRF_CHECK"
            HELM_SET_TYK_DEVPORTAL_EXTRAENVS="$HELM_SET_TYK_DEVPORTAL_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX].value=true"
            # remember to increment HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX so that we keep in sync
            let HELM_TYK_DEVPORTAL_EXTRAENVS_NEXT_INDEX+=1
          else
            HELM_TYK_DEVPORTAL_ENABLED=false
          fi
          # turn on TYK_GW_ENABLEHASHEDKEYSLISTING=true because the chart doesn't do that
          HELM_SET_TYK_GATEWAY_EXTRAENVS="$HELM_SET_TYK_GATEWAY_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX].name=TYK_GW_ENABLEHASHEDKEYSLISTING"
          HELM_SET_TYK_GATEWAY_EXTRAENVS="$HELM_SET_TYK_GATEWAY_EXTRAENVS --set tyk-dev-portal.extraEnvs[$HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX].value=true"
          # remember to increment HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX so that we keep in sync
          let HELM_TYK_GATEWAY_EXTRAENVS_NEXT_INDEX+=1
        elif [[ $HSBX_CHART == 'tyk-data-plane' ]]; then
            waitStatefulSetReady tyk-redis-master tyk-redis-replicas
            setupRemoteControlPlaneSecrets
        fi
        exit
        runHelm
        saveOrgAndAdminKey
        echo "[INFO]$NAMESPACE"
        showTykVersions
        listPods
        reportSanboxInfo
      else
        echo "[FATAL]Namespace $NAMESPACE already exists"
        exit 1
      fi
      ;;
    info)
      shift
      if [[ $# -lt 1 ]]; then
        # give info on all if none given
        typeset allSandboxes
        allSandboxes=$(getAllSandboxes)
        if [[ $allSandboxes = '' ]]; then
          echo "[INFO]No helm sandboxes configured"
          exit 0
        fi
        set $allSandboxes
      fi
      for NAMESPACE in $(getNamespaceNames $*); do
        if namespaceExists $NAMESPACE; then
          # set HSBX_DATABASE for this namespace
          getDatabaseType
          echo "[INFO]$NAMESPACE"
          showTykVersions
          listPods
          reportSanboxInfo
          echo
        else
          echo "[WARN]Namespace '$NAMESPACE' not found"
        fi
      done
      ;;
    get)
      shift
      NAMESPACE=$(getNamespaceNames $1)
      shift
      case $1 in
        [Vv]alues)
          helmRelease=$(getHelmRelease)
          echo [INFO]helm get values $(getHelmRelease) -n $NAMESPACE
          helm get values $(getHelmRelease) -n $NAMESPACE
          ;;
        [Dd]escription)
          getDescription
          ;;
        [Dd]ashboard)
          echo "http://$IP:$(getDashboardPort)/"
          ;;
        [Gg]ateway)
          if [[ $(getHTTPS) == 'true' ]]; then
            echo "https://$IP:$(getGatewayPort)/"
          else
            echo "http://$IP:$(getGatewayPort)/"
          fi
          ;;
        [Rr]edis-password)
          echo $(getRedisPassword)
          ;;
        [Rr]edis-port)
          getRedisPort
          ;;
        [Rr]edis)
          echo "REDISCLI_AUTH=$(getRedisPassword) redis-cli -h $IP -p $(getRedisPort)"
          ;;
        [Cc]hart)
          getChart
          ;;
        [Rr]elease)
          getHelmRelease
          ;;
        *)
          echo "[FATAL]get $1 not implemented"
          help
          exit 1
          ;;
      esac
      ;;
    log*)
      shift
      if [[ $# -lt 2 ]]; then
        echo "[FATAL]Must provide namespace and pod names"
        exit 1
      fi
      NAMESPACE=$(getNamespaceNames $1)
      shift
      showLogs $1
      ;;
    shell)
      shift
      if [[ $# -lt 1 ]]; then
        echo "[FATAL]Must provide namespace"
        exit 1
      fi
      NAMESPACE=$(getNamespaceNames $1)
      setHelmRelease
      shift
      if namespaceExists $NAMESPACE; then
        runShell $*
      else
        echo "[FATAL]No such ksandbox: $NAMESPACE"
      fi
      ;;
    rm | del*)
      shift
      if [[ $# -lt 1 ]]; then
        echo "[FATAL]Must provide namespace"
        exit 1
      fi
      for NAMESPACE in $(getNamespaceNames $*); do
        if namespaceExists $NAMESPACE; then
          echo "[INFO]Deleting Namespace $NAMESPACE"
          kubectl delete namespace $NAMESPACE --wait
        fi
      done
      tidyReleasedPVCs
      ;;
    version*)
      shift
      if [[ $# -lt 1 ]]; then
        # give info on all if none given
        typeset allSandboxes
        allSandboxes=$(getAllSandboxes)
        if [[ $allSandboxes = "" ]]; then
          echo "[INFO]No sandboxes configured"
          exit 0
        fi
        set $allSandboxes
      fi
      for NAMESPACE in $(getNamespaceNames $*); do
        echo "[INFO]$NAMESPACE deployed versions"
        for deployment in $(kubectl get deploy --no-headers=true -n $NAMESPACE | awk '{print $1}'); do
          echo "   $deployment: $(kubectl get deploy $deployment -n $NAMESPACE -o yaml | yq ".spec.template.spec.containers.[].image" | xargs)"
        done | sort
        echo
      done
      ;;
    *)
      echo "[FATAL]$1 not implemented"
      help
      exit 1
      ;;
    :)
      echo "[FATAL]Option -$OPTARG requires an arguement."
      exit 1
      ;;
    \?)
      echo "[FATAL]Invalid option: -$OPTARG"
      exit 1
      ;;
  esac
else
  help
  exit 1
fi

